# -*- coding: utf-8 -*-
"""Курсовая Визуализация погодных данных.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jz3VXSrUfGX-g9_MCzVRjCZ4kJVykM9n

# Курсовая работа: Визуализатор погодных данных

## Анализ данных

* Провести предварительный анализ данных: загрузить, очистить и визуализировать с использованием библиотек Pandas, Matplotlib и Seaborn.

* Выявить основные характеристики данных (тип, распределение, наличие пропусков,
выбросов).

* Подготовить данные для интерактивной визуализации: нормализовать, агрегировать и преобразовать признаки.
"""

!pip install jupyter-dash

!pip install --upgrade plotly

from jupyter_dash import JupyterDash
from dash import dcc, html, Input, Output

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from google.colab import drive
from sklearn.preprocessing import MinMaxScaler
import plotly.express as px
from ipywidgets import interact, Dropdown, FloatRangeSlider
from IPython.display import display
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

"""### Загрузка датасетов"""

drive.mount('/content/drive/',force_remount=True)

!ls /content/drive/MyDrive/data/CourseDatasets

"""### Создание соответствущих дата фреймов"""

cities_weather_df = pd.read_csv('drive/MyDrive/data/CourseDatasets/cities.csv')
countries_weather_df = pd.read_csv('drive/MyDrive/data/CourseDatasets/countries.csv')

"""### Первые строки и информация о датасете: Города"""

cities_weather_df.head(20)

cities_weather_df.info()

"""### Первые строки и информация о датасете: Страны"""

countries_weather_df.head(20)

countries_weather_df.info()

"""### Проверка пропусков"""

print(cities_weather_df.isna().sum())

print(countries_weather_df.isna().sum())

"""### Очистка от дубликатов и очистка от критических пропусков"""

cities_weather_df.drop_duplicates(inplace=True)
cities_weather_df.dropna(inplace=True)

countries_weather_df.drop_duplicates(inplace=True)
countries_weather_df.dropna( inplace=True)

print(countries_weather_df.isna().sum())

print(cities_weather_df.isna().sum())

"""### Описательная статистика"""

print(cities_weather_df.describe())

print(countries_weather_df.describe())

"""## Выделение категориальных и числовых признаков"""

num_cols_countries = countries_weather_df.select_dtypes(include=[np.number]).columns
num_cols_cities = cities_weather_df.select_dtypes(include=[np.number]).columns

cat_cols_cities = cities_weather_df.select_dtypes(include=['object', 'category']).columns
cat_cols_countries = countries_weather_df.select_dtypes(include=['object', 'category']).columns

"""### Визуализация выбросов и некоторых распределений"""

for col in num_cols_countries:
    plt.figure(figsize=(10, 10))
    sns.histplot(countries_weather_df[col], kde=True)
    plt.title(f'Распределение {col} (countries)')
    plt.show()

for col in num_cols_cities:
    plt.figure(figsize=(10, 10))
    sns.boxplot(x=cities_weather_df[col])
    plt.title(f'Выбросы в {col} (cities)')
    plt.show()

"""### Матрица корреляции для датасета Cities"""

plt.figure(figsize=(10, 10))
sns.heatmap(cities_weather_df.corr(numeric_only=True), annot=True, cmap="coolwarm")
plt.title("Корреляционная матрица (cities)")
plt.show()

"""### Матрица корреляции для датасета Countries"""

plt.figure(figsize=(10, 10))
sns.heatmap(countries_weather_df.corr(numeric_only=True), annot=True, cmap="coolwarm")
plt.title("Корреляционная матрица (countries)")
plt.show()

"""### Нормализация числовых признаков"""

scaler = MinMaxScaler()

countries_norm = countries_weather_df.copy()
cities_norm = cities_weather_df.copy()

countries_norm[num_cols_countries] = scaler.fit_transform(countries_weather_df[num_cols_countries])
cities_norm[num_cols_cities] = scaler.fit_transform(cities_weather_df[num_cols_cities])

countries_norm.head()

cities_norm.head()

"""### Агрегация по странам датасета Cities"""

if 'country' in cities_norm.columns:
    city_agg = cities_norm.groupby('country')[num_cols_cities].mean().reset_index()
    print("\n=== Агрегированные данные по странам ===")
    print(city_agg.head())
else:
    print("⚠️ В cities нет столбца 'country' для агрегации.")

"""### Агрегация по регионам для датасета Countries"""

agg_col = None
if 'region' in countries_norm.columns:
    agg_col = 'region'
elif 'continent' in countries_norm.columns:
    agg_col = 'continent'

if agg_col:
    country_agg = (
        countries_norm.groupby(agg_col)[num_cols_countries]
        .agg(['mean', 'median', 'min', 'max'])
        .reset_index()
    )
    print(f"\n=== Агрегированные данные по {agg_col} (countries) ===")
    print(country_agg.head())
else:
    print("\n⚠️ В countries нет признаков 'region' или 'continent' для агрегации.")
    country_agg = None

"""### Интерактивные графики scatter plot, позволяющие отфильтровать данные по стране или по региону или населению."""

def show_plot(x_col, y_col, pop_range=(0, 1), country=None):
    df = cities_norm.copy()
    if 'population' in df.columns:
        df = df[(df['population'] >= pop_range[0]) & (df['population'] <= pop_range[1])]
    if country and 'country' in df.columns:
        df = df[df['country'] == country]
    if df.empty:
        print("Нет данных для отображения. Измени фильтры.")
        return
    fig = px.scatter(
        df,
        x=x_col,
        y=y_col,
        color='country' if 'country' in df.columns else None,
        hover_data=['city'] if 'city' in df.columns else None,
        title=f"{x_col} vs {y_col}",
        template='plotly_white'
    )
    fig.show()

interact(
    show_plot,
    x_col=Dropdown(options=num_cols_cities, value=num_cols_cities[0], description='Ось X'),
    y_col=Dropdown(options=num_cols_cities, value=num_cols_cities[1], description='Ось Y'),
    pop_range=FloatRangeSlider(value=[0, 1], min=0, max=1, step=0.05, description='Население'),
    country=Dropdown(
        options=[None] + (list(cities_norm['country'].unique()) if 'country' in cities_norm.columns else []),
        value=None,
        description='Страна'
    )
)

def show_plot(x_col, y_col, pop_range=(0, 1), country=None):
    df = cities_norm.copy()
    if 'population' in df.columns:
        df = df[(df['population'] >= pop_range[0]) & (df['population'] <= pop_range[1])]
    if country and 'country' in df.columns:
        df = df[df['country'] == country]
    if df.empty:
        print("Нет данных для отображения. Измени фильтры.")
        return
    fig = px.scatter(
        df,
        x=x_col,
        y=y_col,
        color='country' if 'country' in df.columns else None,
        hover_data=['city'] if 'city' in df.columns else None,
        title=f"{x_col} vs {y_col}",
        template='plotly_white'
    )
    fig.show()

interact(
    show_plot,
    x_col=Dropdown(options=num_cols_cities, value=num_cols_cities[0], description='Ось X'),
    y_col=Dropdown(options=num_cols_cities, value=num_cols_cities[1], description='Ось Y'),
    pop_range=FloatRangeSlider(value=[0, 1], min=0, max=1, step=0.05, description='Население'),
    country=Dropdown(
        options=[None] + (list(cities_norm['country'].unique()) if 'country' in cities_norm.columns else []),
        value=None,
        description='Страна'
    )
)

def show_plot(x_col, y_col, pop_range=(0, 1), region=None):
    df = countries_norm.copy()
    if 'population' in df.columns:
        df = df[(df['population'] >= pop_range[0]) & (df['population'] <= pop_range[1])]
    if region and 'region' in df.columns:
        df = df[df['region'] == region]
    if df.empty:
        print("Нет данных для отображения. Измени фильтры.")
        return
    fig = px.scatter(
        df,
        x=x_col,
        y=y_col,
        color='region' if 'region' in df.columns else None,
        hover_data=['country'] if 'country' in df.columns else None,
        title=f"{x_col} vs {y_col}",
        template='plotly_white'
    )
    fig.show(renderer="colab")

interact(
    show_plot,
    x_col=Dropdown(options=num_cols_countries, value=num_cols_countries[0], description='Ось X'),
    y_col=Dropdown(options=num_cols_countries, value=num_cols_countries[1], description='Ось Y'),
    pop_range=FloatRangeSlider(value=[0, 1e9], min=0, max=1e9, step=1e7, description='Население'),
    region=Dropdown(
        options=[None] + (list(countries_norm['region'].unique()) if 'region' in countries_norm.columns else []),
        value=None,
        description='Регион'
    )
)

"""### Визуализация кластеризации и всех распределений с возможностью менять параметры

перед реализацией на дэшборде
"""

# 3. Функции визуализации
# -----------------------------------------------------

def plot_distribution_cities(column):
    plt.figure(figsize=(6,4))
    sns.histplot(cities_weather_df[column], kde=True)
    plt.title(f"Распределение (Cities): {column}")
    plt.show()

def plot_distribution_countries(column):
    plt.figure(figsize=(6,4))
    sns.histplot(countries_weather_df[column], kde=True)
    plt.title(f"Распределение (Countries): {column}")
    plt.show()

def plot_scatter_cities(col_x, col_y):
    plt.figure(figsize=(6,4))
    sns.scatterplot(data=cities_weather_df, x=col_x, y=col_y)
    plt.title(f"Scatter: {col_x} vs {col_y}")
    plt.show()

def plot_scatter_countries(col_x, col_y):
    plt.figure(figsize=(6,4))
    sns.scatterplot(data=countries_weather_df, x=col_x, y=col_y)
    plt.title(f"Scatter: {col_x} vs {col_y}")
    plt.show()

# -----------------------------------------------------
# 4. Методы анализа: K-Means кластеризация
# -----------------------------------------------------

def kmeans_cities(n_clusters):
    km = KMeans(n_clusters=n_clusters, random_state=42)
    labels = km.fit_predict(cities_norm[num_cols_cities])

    # PCA для отображения кластеров
    pca = PCA(n_components=2)
    reduced = pca.fit_transform(cities_norm[num_cols_cities])

    plt.figure(figsize=(6,5))
    plt.scatter(reduced[:,0], reduced[:,1], c=labels, cmap="tab10")
    plt.title("K-Means (Cities) — PCA 2D")
    plt.show()

def kmeans_countries(n_clusters):
    km = KMeans(n_clusters=n_clusters, random_state=42)
    labels = km.fit_predict(countries_norm[num_cols_countries])

    pca = PCA(n_components=2)
    reduced = pca.fit_transform(countries_norm[num_cols_countries])

    plt.figure(figsize=(6,5))
    plt.scatter(reduced[:,0], reduced[:,1], c=labels, cmap="tab10")
    plt.title("K-Means (Countries) — PCA 2D")
    plt.show()

# -----------------------------------------------------
# 5. Интерактивные элементы
# -----------------------------------------------------

print("=== Распределения (Cities) ===")
interact(
    plot_distribution_cities,
    column=Dropdown(options=cities_weather_df.columns, description="Column")
)

print("=== Распределения (Countries) ===")
interact(
    plot_distribution_countries,
    column=Dropdown(options=countries_weather_df.columns, description="Column")
)

print("=== Scatter (Cities) ===")
interact(
    plot_scatter_cities,
    col_x=Dropdown(options=num_cols_cities, description="X"),
    col_y=Dropdown(options=num_cols_cities, description="Y")
)

print("=== Scatter (Countries) ===")
interact(
    plot_scatter_countries,
    col_x=Dropdown(options=num_cols_countries, description="X"),
    col_y=Dropdown(options=num_cols_countries, description="Y")
)

print("=== K-Means (Cities) ===")
interact(
    kmeans_cities,
    n_clusters=(2,10,1)
)

print("=== K-Means (Countries) ===")
interact(
    kmeans_countries,
    n_clusters=(2,10,1)
)
