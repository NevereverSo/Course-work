# -*- coding: utf-8 -*-
"""CourseWork-prefinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aD6mT-NBBgiOpKOlwH5ikdXhMEburcov
"""

# ----------------------------------------------------------
# app.py â€” Streamlit Dashboard for Weather Data (Enhanced)
# ----------------------------------------------------------

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import seaborn as sns
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# ML libraries
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans, DBSCAN
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import silhouette_score, r2_score, mean_absolute_error
from sklearn.decomposition import PCA
from sklearn.model_selection import train_test_split
import warnings
warnings.filterwarnings('ignore')

pip install statsmodels

# Time series
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

st.set_page_config(
    page_title="Weather Analytics Dashboard",
    layout="wide",
    page_icon="ğŸŒ¤ï¸"
)

# ----------------------------------------------------------
# LOAD DATA
# ----------------------------------------------------------
@st.cache_data
def load_data():
    countries_weather_df = pd.read_csv("countries.csv")
    cities_weather_df = pd.read_csv("cities.csv")
    daily_weather_df = pd.read_csv("daily_weather_smallest.csv")
    return countries_weather_df, cities_weather_df, daily_weather_df

countries_weather_df, cities_weather_df, daily_weather_df = load_data()

# ----------------------------------------------------------
# DATA PREPROCESSING
# ----------------------------------------------------------
def preprocess_data(df_list, names):
    processed = []
    for df, name in zip(df_list, names):
        df_clean = df.copy()
        df_clean.drop_duplicates(inplace=True)

        # Store info about missing values before dropping
        missing_info = df_clean.isnull().sum()

        # For daily weather, we might want to fill some missing values
        if name == 'daily':
            numeric_cols = df_clean.select_dtypes(include=[np.number]).columns
            df_clean[numeric_cols] = df_clean[numeric_cols].fillna(df_clean[numeric_cols].mean())
            # Convert date if exists
            if 'date' in df_clean.columns:
                df_clean['date'] = pd.to_datetime(df_clean['date'])
                df_clean['year'] = df_clean['date'].dt.year
                df_clean['month'] = df_clean['date'].dt.month
                df_clean['season'] = df_clean['month'] % 12 // 3 + 1
                season_map = {1: 'Winter', 2: 'Spring', 3: 'Summer', 4: 'Fall'}
                df_clean['season_name'] = df_clean['season'].map(season_map)

        processed.append(df_clean)
    return processed

countries_weather_df, cities_weather_df, daily_weather_df = preprocess_data(
    [countries_weather_df, cities_weather_df, daily_weather_df],
    ['countries', 'cities', 'daily']
)

# ----------------------------------------------------------
# HELPER FUNCTIONS
# ----------------------------------------------------------
def create_kpi_card(title, value, delta=None, delta_color="normal"):
    """Create a KPI card for dashboard"""
    return {
        'title': title,
        'value': value,
        'delta': delta,
        'delta_color': delta_color
    }

def time_series_decomposition(data, column, period=365):
    """Decompose time series into trend, seasonal, and residual"""
    decomposition = seasonal_decompose(data[column].values, model='additive', period=period)
    return decomposition

# ----------------------------------------------------------
# SIDEBAR
# ----------------------------------------------------------
st.sidebar.title("ğŸŒ¤ï¸ Weather Analytics")
st.sidebar.markdown("---")

# ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ñ
page = st.sidebar.radio(
    "ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ñ",
    ["ğŸ“Š Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", "ğŸ” Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°", "ğŸ“ˆ ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ", "â„¹ï¸ Ğ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğµ"]
)

st.sidebar.markdown("---")

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹
st.sidebar.header("Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹")

# Ğ”Ğ°Ñ‚Ğ°ÑĞµÑ‚ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°
dataset_choice = st.sidebar.selectbox(
    "ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ´Ğ°Ñ‚Ğ°ÑĞµÑ‚:",
    ["Daily Weather", "Cities", "Countries"]
)

# Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€ (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ´Ğ°Ñ‚Ñ‹)
if dataset_choice == "Daily Weather" and 'date' in daily_weather_df.columns:
    min_date = daily_weather_df['date'].min()
    max_date = daily_weather_df['date'].max()
    date_range = st.sidebar.date_input(
        "Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ Ğ´Ğ°Ñ‚:",
        [min_date, max_date]
    )

st.sidebar.markdown("---")
st.sidebar.info("""
**Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ñ:**
1. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ Ğ½Ğ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ğ¸
2. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹ Ğ´Ğ»Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
3. Ğ’Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ Ñ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ°Ğ¼Ğ¸
""")

# ==========================================================
# PAGE 1 â€” RAW DATA VISUALIZATION (ENHANCED)
# ==========================================================
if page == "ğŸ“Š Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…":

    # Header
    col1, col2 = st.columns([3, 1])
    with col1:
        st.title("ğŸ“Š Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…")
    with col2:
        st.metric("Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹", f"{len(daily_weather_df):,}")

    # KPI Cards
    st.subheader("ğŸ“ˆ ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸")

    # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ´Ğ°Ñ‚Ğ°ÑĞµÑ‚Ğ° Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ KPI
    kpi_dataset = st.selectbox("Ğ”Ğ°Ñ‚Ğ°ÑĞµÑ‚ Ğ´Ğ»Ñ KPI:", ["Daily Weather", "Cities", "Countries"])

    if kpi_dataset == "Daily Weather":
        df_kpi = daily_weather_df
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Ğ“Ğ¾Ñ€Ğ¾Ğ´Ğ°", df_kpi['city_name'].nunique() if 'city_name' in df_kpi.columns else "N/A")
        with col2:
            st.metric("Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ Ğ´Ğ°Ñ‚",
                     f"{df_kpi['date'].min().date() if 'date' in df_kpi.columns else 'N/A'} - "
                     f"{df_kpi['date'].max().date() if 'date' in df_kpi.columns else 'N/A'}")
        with col3:
            numeric_cols = df_kpi.select_dtypes(include=[np.number]).columns
            st.metric("Ğ§Ğ¸ÑĞ»Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²", len(numeric_cols))
        with col4:
            st.metric("ĞŸÑ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ½Ñ‹Ñ… Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹", df_kpi.isnull().sum().sum())

    # Tabs for different visualizations
    tab1, tab2, tab3, tab4 = st.tabs([
        "ğŸ“‹ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°",
        "ğŸ“Š Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ",
        "ğŸ”— ĞšĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ğ¸",
        "ğŸŒ Ğ“ĞµĞ¾Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ"
    ])

    with tab1:
        st.header("Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸ Ğ¾Ğ¿Ğ¸ÑĞ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°")

        # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ´Ğ°Ñ‚Ğ°ÑĞµÑ‚Ğ° Ğ´Ğ»Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
        dataset_for_table = st.selectbox("Ğ”Ğ°Ñ‚Ğ°ÑĞµÑ‚:", ["Daily Weather", "Cities", "Countries"])

        if dataset_for_table == "Daily Weather":
            df_table = daily_weather_df
        elif dataset_for_table == "Cities":
            df_table = cities_weather_df
        else:
            df_table = countries_weather_df

        # ĞŸĞ¾Ğ¸ÑĞº Ğ¸ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ
        col1, col2 = st.columns(2)
        with col1:
            search_term = st.text_input("ğŸ” ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğµ:", "")
        with col2:
            items_per_page = st.slider("Ğ—Ğ°Ğ¿Ğ¸ÑĞµĞ¹ Ğ½Ğ° ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ:", 10, 100, 20)

        # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ¸ÑĞºĞ°
        if search_term:
            df_display = df_table[df_table.apply(
                lambda row: row.astype(str).str.contains(search_term, case=False).any(),
                axis=1
            )]
        else:
            df_display = df_table

        # ĞŸĞ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ
        total_pages = max(1, len(df_display) // items_per_page)
        page_num = st.number_input("Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°:", 1, total_pages, 1)

        start_idx = (page_num - 1) * items_per_page
        end_idx = min(start_idx + items_per_page, len(df_display))

        # ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
        st.dataframe(
            df_display.iloc[start_idx:end_idx],
            use_container_width=True,
            height=400
        )

        st.caption(f"ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ğ½Ğ¾ {start_idx+1}-{end_idx} Ğ¸Ğ· {len(df_display)} Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹")

        # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
        st.subheader("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°")
        numeric_cols_table = df_table.select_dtypes(include=[np.number]).columns
        if len(numeric_cols_table) > 0:
            st.dataframe(df_table[numeric_cols_table].describe())

        # Missing values
        st.subheader("ğŸ” ĞŸÑ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ")
        missing_df = pd.DataFrame({
            'ĞšĞ¾Ğ»Ğ¾Ğ½ĞºĞ°': df_table.columns,
            'ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ¸': df_table.isnull().sum().values,
            '% Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ¾Ğ²': (df_table.isnull().sum().values / len(df_table) * 100).round(2)
        })
        st.dataframe(missing_df[missing_df['ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ¸'] > 0])

    with tab2:
        st.header("Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²")

        dataset_for_dist = st.selectbox("Ğ”Ğ°Ñ‚Ğ°ÑĞµÑ‚ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ñ€Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğ¹:",
                                       ["Daily Weather", "Cities", "Countries"])

        if dataset_for_dist == "Daily Weather":
            df_dist = daily_weather_df
            num_cols = df_dist.select_dtypes(include=[np.number]).columns
            cat_cols = df_dist.select_dtypes(exclude=[np.number]).columns
        elif dataset_for_dist == "Cities":
            df_dist = cities_weather_df
            num_cols = df_dist.select_dtypes(include=[np.number]).columns
            cat_cols = df_dist.select_dtypes(exclude=[np.number]).columns
        else:
            df_dist = countries_weather_df
            num_cols = df_dist.select_dtypes(include=[np.number]).columns
            cat_cols = df_dist.select_dtypes(exclude=[np.number]).columns

        # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ñ‚Ğ¸Ğ¿Ğ° Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
        viz_type = st.radio(
            "Ğ¢Ğ¸Ğ¿ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:",
            ["Ğ“Ğ¸ÑÑ‚Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°", "Box Plot", "Violin Plot", "Density Plot", "Bar Chart"]
        )

        if viz_type in ["Ğ“Ğ¸ÑÑ‚Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°", "Box Plot", "Violin Plot", "Density Plot"]:
            col_selected = st.selectbox("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ğº:", num_cols)

            if viz_type == "Ğ“Ğ¸ÑÑ‚Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°":
                fig = px.histogram(df_dist, x=col_selected, nbins=50,
                                  title=f"Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ {col_selected}")
            elif viz_type == "Box Plot":
                fig = px.box(df_dist, y=col_selected, title=f"Box Plot {col_selected}")
            elif viz_type == "Violin Plot":
                fig = px.violin(df_dist, y=col_selected, title=f"Violin Plot {col_selected}")
            else:  # Density Plot
                fig = px.density_contour(df_dist, x=col_selected,
                                        title=f"ĞŸĞ»Ğ¾Ñ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ñ€Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ {col_selected}")

            st.plotly_chart(fig, use_container_width=True)

            # Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Ğ¡Ñ€ĞµĞ´Ğ½ĞµĞµ", f"{df_dist[col_selected].mean():.2f}")
            with col2:
                st.metric("ĞœĞµĞ´Ğ¸Ğ°Ğ½Ğ°", f"{df_dist[col_selected].median():.2f}")
            with col3:
                st.metric("Ğ¡Ñ‚Ğ´. Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğµ", f"{df_dist[col_selected].std():.2f}")
            with col4:
                st.metric("ĞÑĞ¸Ğ¼Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ", f"{df_dist[col_selected].skew():.2f}")

        else:  # Bar Chart Ğ´Ğ»Ñ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ñ…
            if len(cat_cols) > 0:
                cat_selected = st.selectbox("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ğº:", cat_cols)
                top_n = st.slider("ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ:", 5, 50, 10)

                counts = df_dist[cat_selected].value_counts().head(top_n).reset_index()
                counts.columns = [cat_selected, 'count']

                fig = px.bar(counts, x=cat_selected, y='count',
                            title=f"Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ {cat_selected} (Ñ‚Ğ¾Ğ¿-{top_n})")
                st.plotly_chart(fig, use_container_width=True)

    with tab3:
        st.header("ĞšĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·")

        dataset_for_corr = st.selectbox("Ğ”Ğ°Ñ‚Ğ°ÑĞµÑ‚ Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ğ¹:",
                                       ["Daily Weather", "Cities", "Countries"])

        if dataset_for_corr == "Daily Weather":
            df_corr = daily_weather_df
        elif dataset_for_corr == "Cities":
            df_corr = cities_weather_df
        else:
            df_corr = countries_weather_df

        numeric_cols_corr = df_corr.select_dtypes(include=[np.number]).columns

        if len(numeric_cols_corr) > 1:
            # Heatmap
            corr_matrix = df_corr[numeric_cols_corr].corr()

            fig = px.imshow(corr_matrix,
                           text_auto=True,
                           aspect="auto",
                           title="ĞšĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ğ¾Ğ½Ğ½Ğ°Ñ Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†Ğ°",
                           color_continuous_scale='RdBu_r')
            st.plotly_chart(fig, use_container_width=True)

            # Scatter matrix
            st.subheader("ĞœĞ°Ñ‚Ñ€Ğ¸Ñ†Ğ° Ñ€Ğ°ÑÑĞµÑĞ½Ğ¸Ñ")
            selected_cols = st.multiselect(
                "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¸ Ğ´Ğ»Ñ Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ†Ñ‹ Ñ€Ğ°ÑÑĞµÑĞ½Ğ¸Ñ:",
                numeric_cols_corr.tolist(),
                default=numeric_cols_corr[:4].tolist()
            )

            if len(selected_cols) >= 2:
                fig = px.scatter_matrix(df_corr[selected_cols])
                st.plotly_chart(fig, use_container_width=True)

            # Top correlations
            st.subheader("ĞĞ°Ğ¸Ğ±Ğ¾Ğ»ĞµĞµ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ğ¼Ñ‹Ğµ ĞºĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ğ¸")
            corr_pairs = []
            for i in range(len(corr_matrix.columns)):
                for j in range(i+1, len(corr_matrix.columns)):
                    corr_pairs.append({
                        'ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº 1': corr_matrix.columns[i],
                        'ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº 2': corr_matrix.columns[j],
                        'ĞšĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ñ': corr_matrix.iloc[i, j]
                    })

            corr_df = pd.DataFrame(corr_pairs)
            corr_df['abs_corr'] = corr_df['ĞšĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ñ'].abs()

            top_n_corr = st.slider("ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾Ğ¿-ĞºĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ğ¹:", 5, 50, 10)
            top_corr = corr_df.nlargest(top_n_corr, 'abs_corr')

            st.dataframe(top_corr[['ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº 1', 'ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº 2', 'ĞšĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ñ']])

    with tab4:
        st.header("Ğ“ĞµĞ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ")

        if 'latitude' in cities_weather_df.columns and 'longitude' in cities_weather_df.columns:

            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ° Ğ´Ğ»Ñ Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
            numeric_cols_geo = cities_weather_df.select_dtypes(include=[np.number]).columns

            color_by = st.selectbox(
                "Ğ¦Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¾Ğµ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾:",
                ['None'] + numeric_cols_geo.tolist()
            )

            size_by = st.selectbox(
                "Ğ Ğ°Ğ·Ğ¼ĞµÑ€ Ñ‚Ğ¾Ñ‡ĞµĞº Ğ¿Ğ¾:",
                ['None'] + numeric_cols_geo.tolist()
            )

            # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸ÑĞ¼
            if color_by != 'None':
                min_val, max_val = st.slider(
                    f"Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ Ğ´Ğ»Ñ {color_by}:",
                    float(cities_weather_df[color_by].min()),
                    float(cities_weather_df[color_by].max()),
                    (float(cities_weather_df[color_by].min()),
                     float(cities_weather_df[color_by].max()))
                )
                df_geo = cities_weather_df[
                    (cities_weather_df[color_by] >= min_val) &
                    (cities_weather_df[color_by] <= max_val)
                ]
            else:
                df_geo = cities_weather_df

            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹
            fig = px.scatter_geo(df_geo,
                                lat='latitude',
                                lon='longitude',
                                color=color_by if color_by != 'None' else None,
                                size=size_by if size_by != 'None' else None,
                                hover_name='city_name' if 'city_name' in df_geo.columns else None,
                                title='Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¾Ğ²',
                                projection='natural earth')

            st.plotly_chart(fig, use_container_width=True)

# ==========================================================
# PAGE 2 â€” ANALYSIS RESULTS (ENHANCED)
# ==========================================================
elif page == "ğŸ” Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°":

    st.title("ğŸ” Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…")

    # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°
    analysis_method = st.selectbox(
        "ĞœĞµÑ‚Ğ¾Ğ´ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°:",
        ["ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ", "Ğ ĞµĞ³Ñ€ĞµÑÑĞ¸Ñ", "ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ÑĞ´Ğ¾Ğ²", "PCA - ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚"]
    )

    # ĞĞ±Ñ‰Ğ¸Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
    st.sidebar.header("ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°")

    # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ´Ğ°Ñ‚Ğ°ÑĞµÑ‚Ğ°
    if analysis_method in ["ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ", "Ğ ĞµĞ³Ñ€ĞµÑÑĞ¸Ñ", "PCA - ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚"]:
        analysis_dataset = st.sidebar.selectbox(
            "Ğ”Ğ°Ñ‚Ğ°ÑĞµÑ‚ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°:",
            ["Daily Weather", "Cities", "Countries"]
        )
    else:
        analysis_dataset = "Daily Weather"

    if analysis_dataset == "Daily Weather":
        df_analysis = daily_weather_df
        df_norm = daily_weather_df.copy()
        scaler = StandardScaler()
        numeric_cols = df_analysis.select_dtypes(include=[np.number]).columns
        df_norm[numeric_cols] = scaler.fit_transform(df_analysis[numeric_cols])
    elif analysis_dataset == "Cities":
        df_analysis = cities_weather_df
        df_norm = cities_weather_df.copy()
        scaler = StandardScaler()
        numeric_cols = df_analysis.select_dtypes(include=[np.number]).columns
        df_norm[numeric_cols] = scaler.fit_transform(df_analysis[numeric_cols])
    else:
        df_analysis = countries_weather_df
        df_norm = countries_weather_df.copy()
        scaler = StandardScaler()
        numeric_cols = df_analysis.select_dtypes(include=[np.number]).columns
        df_norm[numeric_cols] = scaler.fit_transform(df_analysis[numeric_cols])

    # ========== ĞšĞ›ĞĞ¡Ğ¢Ğ•Ğ Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ ==========
    if analysis_method == "ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ":
        st.header("ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…")

        col1, col2 = st.columns(2)

        with col1:
            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ°
            cluster_algo = st.selectbox(
                "ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:",
                ["K-Means", "DBSCAN"]
            )

            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²
            features = st.multiselect(
                "ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¸ Ğ´Ğ»Ñ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:",
                numeric_cols.tolist(),
                default=numeric_cols[:2].tolist() if len(numeric_cols) >= 2 else []
            )

        with col2:
            if cluster_algo == "K-Means":
                n_clusters = st.slider("ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ²:", 2, 10, 3)
                n_init = st.slider("ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¹:", 1, 20, 10)
            else:  # DBSCAN
                eps = st.slider("EPS (Ñ€Ğ°Ğ´Ğ¸ÑƒÑ):", 0.1, 5.0, 0.5, 0.1)
                min_samples = st.slider("ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ·Ñ†Ğ¾Ğ²:", 1, 20, 5)

        if len(features) >= 2:
            X = df_norm[features].dropna()

            if cluster_algo == "K-Means":
                # K-Means
                kmeans = KMeans(n_clusters=n_clusters, n_init=n_init, random_state=42)
                clusters = kmeans.fit_predict(X)
                centers = kmeans.cluster_centers_

                # ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ¸
                inertia = kmeans.inertia_
                silhouette = silhouette_score(X, clusters)

                # ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Inertia", f"{inertia:.2f}")
                with col2:
                    st.metric("Silhouette Score", f"{silhouette:.2f}")
                with col3:
                    st.metric("ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ²", n_clusters)

            else:  # DBSCAN
                dbscan = DBSCAN(eps=eps, min_samples=min_samples)
                clusters = dbscan.fit_predict(X)
                n_clusters = len(set(clusters)) - (1 if -1 in clusters else 0)

                if n_clusters > 0:
                    try:
                        silhouette = silhouette_score(X, clusters)
                    except:
                        silhouette = "N/A"

                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ²", n_clusters)
                    with col2:
                        noise_points = sum(clusters == -1)
                        st.metric("Ğ¨ÑƒĞ¼Ğ¾Ğ²Ñ‹Ñ… Ñ‚Ğ¾Ñ‡ĞµĞº", noise_points)
                    with col3:
                        if silhouette != "N/A":
                            st.metric("Silhouette Score", f"{silhouette:.2f}")

            # Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
            df_viz = df_analysis.loc[X.index].copy()
            df_viz['Cluster'] = clusters

            # 2D Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
            if len(features) >= 2:
                fig = px.scatter(
                    df_viz,
                    x=features[0],
                    y=features[1],
                    color='Cluster',
                    title=f"ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ {features[0]} vs {features[1]}",
                    hover_data=df_viz.columns.tolist()
                )

                if cluster_algo == "K-Means":
                    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‚Ñ€Ğ¾Ğ¸Ğ´Ğ¾Ğ²
                    centers_original = scaler.inverse_transform(centers)
                    fig.add_trace(
                        go.Scatter(
                            x=centers_original[:, features.index(features[0])],
                            y=centers_original[:, features.index(features[1])],
                            mode='markers',
                            marker=dict(
                                symbol='x',
                                size=15,
                                color='black',
                                line=dict(width=2)
                            ),
                            name='Ğ¦ĞµĞ½Ñ‚Ñ€Ğ¾Ğ¸Ğ´Ñ‹'
                        )
                    )

                st.plotly_chart(fig, use_container_width=True)

            # 3D Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (ĞµÑĞ»Ğ¸ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾ 3+ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ°)
            if len(features) >= 3:
                fig_3d = px.scatter_3d(
                    df_viz,
                    x=features[0],
                    y=features[1],
                    z=features[2],
                    color='Cluster',
                    title=f"3D ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ"
                )
                st.plotly_chart(fig_3d, use_container_width=True)

            # ĞĞ½Ğ°Ğ»Ğ¸Ğ· ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ²
            st.subheader("ğŸ“Š ĞĞ½Ğ°Ğ»Ğ¸Ğ· ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ²")

            # Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ°Ğ¼
            cluster_stats = df_viz.groupby('Cluster')[numeric_cols.tolist()].mean()
            st.dataframe(cluster_stats)

            # ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾Ñ‡ĞµĞº Ğ² ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ°Ñ…
            cluster_counts = df_viz['Cluster'].value_counts().sort_index()
            fig_counts = px.bar(
                x=cluster_counts.index.astype(str),
                y=cluster_counts.values,
                title="Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ°Ğ¼",
                labels={'x': 'ĞšĞ»Ğ°ÑÑ‚ĞµÑ€', 'y': 'ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾Ñ‡ĞµĞº'}
            )
            st.plotly_chart(fig_counts, use_container_width=True)

    # ========== Ğ Ğ•Ğ“Ğ Ğ•Ğ¡Ğ¡Ğ˜Ğ¯ ==========
    elif analysis_method == "Ğ ĞµĞ³Ñ€ĞµÑÑĞ¸Ñ":
        st.header("Ğ ĞµĞ³Ñ€ĞµÑÑĞ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·")

        col1, col2 = st.columns(2)

        with col1:
            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ°
            reg_algo = st.selectbox(
                "ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ñ€ĞµĞ³Ñ€ĞµÑÑĞ¸Ğ¸:",
                ["Linear Regression", "Ridge", "Lasso", "Random Forest", "Gradient Boosting"]
            )

            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ñ†ĞµĞ»ĞµĞ²Ğ¾Ğ¹ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹
            target = st.selectbox(
                "Ğ¦ĞµĞ»ĞµĞ²Ğ°Ñ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ (Y):",
                numeric_cols.tolist()
            )

        with col2:
            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²
            features = st.multiselect(
                "ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¸ (X):",
                [col for col in numeric_cols.tolist() if col != target],
                default=[col for col in numeric_cols.tolist() if col != target][:3]
            )

            # Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€ĞºĞ°
            test_size = st.slider("Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€ĞºĞ° (%):", 10, 50, 20) / 100

        if target and len(features) > 0:
            # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            X = df_norm[features].dropna()
            y = df_norm[target].loc[X.index]

            # Ğ Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° train/test
            X_train, X_test, y_train, y_test = train_test_split(
                X, y, test_size=test_size, random_state=42
            )

            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸
            if reg_algo == "Linear Regression":
                model = LinearRegression()
            elif reg_algo == "Ridge":
                alpha = st.slider("Alpha (Ridge):", 0.01, 10.0, 1.0, 0.01)
                model = Ridge(alpha=alpha)
            elif reg_algo == "Lasso":
                alpha = st.slider("Alpha (Lasso):", 0.01, 10.0, 1.0, 0.01)
                model = Lasso(alpha=alpha)
            elif reg_algo == "Random Forest":
                n_estimators = st.slider("ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´ĞµÑ€ĞµĞ²ÑŒĞµĞ²:", 10, 200, 100)
                model = RandomForestRegressor(n_estimators=n_estimators, random_state=42)
            else:  # Gradient Boosting
                n_estimators = st.slider("ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´ĞµÑ€ĞµĞ²ÑŒĞµĞ²:", 10, 200, 100)
                learning_rate = st.slider("Learning Rate:", 0.01, 0.3, 0.1, 0.01)
                model = GradientBoostingRegressor(
                    n_estimators=n_estimators,
                    learning_rate=learning_rate,
                    random_state=42
                )

            # ĞĞ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸
            model.fit(X_train, y_train)

            # ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ñ‹
            y_pred_train = model.predict(X_train)
            y_pred_test = model.predict(X_test)

            # ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ¸
            r2_train = r2_score(y_train, y_pred_train)
            r2_test = r2_score(y_test, y_pred_test)
            mae_train = mean_absolute_error(y_train, y_pred_train)
            mae_test = mean_absolute_error(y_test, y_pred_test)

            # ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("RÂ² Train", f"{r2_train:.3f}")
            with col2:
                st.metric("RÂ² Test", f"{r2_test:.3f}")
            with col3:
                st.metric("MAE Train", f"{mae_train:.3f}")
            with col4:
                st.metric("MAE Test", f"{mae_test:.3f}")

            # Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
            tab1, tab2, tab3 = st.tabs(["ğŸ“ˆ ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ñ‹", "ğŸ“Š Ğ’Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²", "ğŸ” ĞÑÑ‚Ğ°Ñ‚ĞºĞ¸"])

            with tab1:
                # Ğ¤Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ vs Ğ¿Ñ€ĞµĞ´ÑĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
                fig = go.Figure()

                fig.add_trace(go.Scatter(
                    x=y_test,
                    y=y_pred_test,
                    mode='markers',
                    name='Test Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ',
                    marker=dict(color='blue')
                ))

                # Ğ›Ğ¸Ğ½Ğ¸Ñ Ğ¸Ğ´ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°
                min_val = min(y_test.min(), y_pred_test.min())
                max_val = max(y_test.max(), y_pred_test.max())
                fig.add_trace(go.Scatter(
                    x=[min_val, max_val],
                    y=[min_val, max_val],
                    mode='lines',
                    name='Ğ˜Ğ´ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·',
                    line=dict(color='red', dash='dash')
                ))

                fig.update_layout(
                    title="Ğ¤Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ vs ĞŸÑ€ĞµĞ´ÑĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ (Test)",
                    xaxis_title="Ğ¤Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ",
                    yaxis_title="ĞŸÑ€ĞµĞ´ÑĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ"
                )

                st.plotly_chart(fig, use_container_width=True)

            with tab2:
                # Ğ’Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²
                if hasattr(model, 'feature_importances_'):
                    importance_df = pd.DataFrame({
                        'ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº': features,
                        'Ğ’Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ': model.feature_importances_
                    }).sort_values('Ğ’Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ', ascending=False)

                    fig = px.bar(
                        importance_df,
                        x='ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº',
                        y='Ğ’Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ',
                        title="Ğ’Ğ°Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ²"
                    )
                    st.plotly_chart(fig, use_container_width=True)
                elif hasattr(model, 'coef_'):
                    coef_df = pd.DataFrame({
                        'ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº': features,
                        'ĞšĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚': model.coef_
                    }).sort_values('ĞšĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚', ascending=False)

                    fig = px.bar(
                        coef_df,
                        x='ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº',
                        y='ĞšĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚',
                        title="ĞšĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ñ‹ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸"
                    )
                    st.plotly_chart(fig, use_container_width=True)

            with tab3:
                # ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ¾ÑÑ‚Ğ°Ñ‚ĞºĞ¾Ğ²
                residuals = y_test - y_pred_test

                fig1 = px.histogram(
                    x=residuals,
                    nbins=30,
                    title="Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¾ÑÑ‚Ğ°Ñ‚ĞºĞ¾Ğ²"
                )
                st.plotly_chart(fig1, use_container_width=True)

                fig2 = px.scatter(
                    x=y_pred_test,
                    y=residuals,
                    title="ĞÑÑ‚Ğ°Ñ‚ĞºĞ¸ vs ĞŸÑ€ĞµĞ´ÑĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ",
                    labels={'x': 'ĞŸÑ€ĞµĞ´ÑĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ', 'y': 'ĞÑÑ‚Ğ°Ñ‚ĞºĞ¸'}
                )
                fig2.add_hline(y=0, line_dash="dash", line_color="red")
                st.plotly_chart(fig2, use_container_width=True)

    # ========== Ğ’Ğ Ğ•ĞœĞ•ĞĞĞ«Ğ• Ğ Ğ¯Ğ”Ğ« ==========
    elif analysis_method == "ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ÑĞ´Ğ¾Ğ²":
        st.header("ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ÑĞ´Ğ¾Ğ²")

        if 'date' not in daily_weather_df.columns:
            st.warning("Ğ”Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ÑĞ´Ğ¾Ğ² Ğ½ÑƒĞ¶Ğ½Ğ° ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ° Ñ Ğ´Ğ°Ñ‚Ğ°Ğ¼Ğ¸.")
        else:
            # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹
            col1, col2 = st.columns(2)

            with col1:
                city = st.selectbox(
                    "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ³Ğ¾Ñ€Ğ¾Ğ´:",
                    daily_weather_df['city_name'].unique() if 'city_name' in daily_weather_df.columns else ['All']
                )

                if city != 'All':
                    df_city = daily_weather_df[daily_weather_df['city_name'] == city]
                else:
                    df_city = daily_weather_df

            with col2:
                variable = st.selectbox(
                    "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ:",
                    numeric_cols.tolist()
                )

            # ĞĞ³Ñ€ĞµĞ³Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ
            df_ts = df_city.groupby('date')[variable].mean().reset_index()
            df_ts = df_ts.sort_values('date')

            # Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€ÑĞ´Ğ°
            fig = px.line(
                df_ts,
                x='date',
                y=variable,
                title=f"{variable} Ğ¿Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ´Ğ»Ñ {city}",
                markers=True
            )
            st.plotly_chart(fig, use_container_width=True)

            # Ğ”ĞµĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€ÑĞ´Ğ°
            st.subheader("ğŸ“Š Ğ”ĞµĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€ÑĞ´Ğ°")

            try:
                # Ğ”Ğ»Ñ Ğ´ĞµĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ½ÑƒĞ¶Ğ½Ñ‹ Ñ€ĞµĞ³ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
                df_ts_regular = df_ts.set_index('date').asfreq('D')
                df_ts_regular[variable] = df_ts_regular[variable].interpolate()

                decomposition = seasonal_decompose(
                    df_ts_regular[variable],
                    model='additive',
                    period=365  # Ğ“Ğ¾Ğ´Ğ¾Ğ²Ğ°Ñ ÑĞµĞ·Ğ¾Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ
                )

                # Ğ“Ñ€Ğ°Ñ„Ğ¸ĞºĞ¸ Ğ´ĞµĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
                fig_decomp = go.Figure()

                fig_decomp.add_trace(go.Scatter(
                    x=decomposition.trend.index,
                    y=decomposition.trend,
                    name='Trend',
                    line=dict(color='blue')
                ))

                fig_decomp.add_trace(go.Scatter(
                    x=decomposition.seasonal.index,
                    y=decomposition.seasonal,
                    name='Seasonal',
                    line=dict(color='green')
                ))

                fig_decomp.add_trace(go.Scatter(
                    x=decomposition.resid.index,
                    y=decomposition.resid,
                    name='Residual',
                    line=dict(color='red')
                ))

                fig_decomp.update_layout(
                    title="Ğ”ĞµĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€ÑĞ´Ğ°",
                    xaxis_title="Ğ”Ğ°Ñ‚Ğ°",
                    yaxis_title="Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"
                )

                st.plotly_chart(fig_decomp, use_container_width=True)

            except Exception as e:
                st.warning(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ´ĞµĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ: {e}")

            # ĞĞ²Ñ‚Ğ¾ĞºĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ñ
            st.subheader("ğŸ“ˆ ĞĞ²Ñ‚Ğ¾ĞºĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ñ")

            fig_acf, ax_acf = plt.subplots(figsize=(10, 4))
            plot_acf(df_ts[variable].dropna(), ax=ax_acf, lags=50)
            st.pyplot(fig_acf)

            fig_pacf, ax_pacf = plt.subplots(figsize=(10, 4))
            plot_pacf(df_ts[variable].dropna(), ax=ax_pacf, lags=50)
            st.pyplot(fig_pacf)

    # ========== PCA ==========
    elif analysis_method == "PCA - ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚":
        st.header("ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚ (PCA)")

        # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¾Ğ² Ğ´Ğ»Ñ PCA
        pca_features = st.multiselect(
            "ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°ĞºĞ¸ Ğ´Ğ»Ñ PCA:",
            numeric_cols.tolist(),
            default=numeric_cols[:5].tolist() if len(numeric_cols) >= 5 else numeric_cols.tolist()
        )

        n_components = st.slider(
            "ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚:",
            2, min(10, len(pca_features)), 3
        )

        if len(pca_features) >= 2:
            X_pca = df_norm[pca_features].dropna()

            # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ PCA
            pca = PCA(n_components=n_components)
            X_pca_transformed = pca.fit_transform(X_pca)

            # ĞĞ±ÑŠÑÑĞ½ĞµĞ½Ğ½Ğ°Ñ Ğ´Ğ¸ÑĞ¿ĞµÑ€ÑĞ¸Ñ
            explained_variance = pca.explained_variance_ratio_
            cumulative_variance = explained_variance.cumsum()

            # Ğ“Ñ€Ğ°Ñ„Ğ¸Ğº Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ´Ğ¸ÑĞ¿ĞµÑ€ÑĞ¸Ğ¸
            fig_var = go.Figure()

            fig_var.add_trace(go.Bar(
                x=[f"PC{i+1}" for i in range(n_components)],
                y=explained_variance,
                name='Ğ”Ğ¾Ğ»Ñ Ğ´Ğ¸ÑĞ¿ĞµÑ€ÑĞ¸Ğ¸'
            ))

            fig_var.add_trace(go.Scatter(
                x=[f"PC{i+1}" for i in range(n_components)],
                y=cumulative_variance,
                name='ĞĞ°ĞºĞ¾Ğ¿Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ´Ğ¸ÑĞ¿ĞµÑ€ÑĞ¸Ñ',
                yaxis='y2'
            ))

            fig_var.update_layout(
                title="ĞĞ±ÑŠÑÑĞ½ĞµĞ½Ğ½Ğ°Ñ Ğ´Ğ¸ÑĞ¿ĞµÑ€ÑĞ¸Ñ Ğ¿Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ°Ğ¼",
                yaxis=dict(title='Ğ”Ğ¾Ğ»Ñ Ğ´Ğ¸ÑĞ¿ĞµÑ€ÑĞ¸Ğ¸'),
                yaxis2=dict(
                    title='ĞĞ°ĞºĞ¾Ğ¿Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ´Ğ¸ÑĞ¿ĞµÑ€ÑĞ¸Ñ',
                    overlaying='y',
                    side='right'
                )
            )

            st.plotly_chart(fig_var, use_container_width=True)

            # 2D Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿ĞµÑ€Ğ²Ñ‹Ñ… Ğ´Ğ²ÑƒÑ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚
            if n_components >= 2:
                df_pca_viz = df_analysis.loc[X_pca.index].copy()
                df_pca_viz['PC1'] = X_pca_transformed[:, 0]
                df_pca_viz['PC2'] = X_pca_transformed[:, 1]

                # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ†Ğ²ĞµÑ‚Ğ° Ğ¿Ğ¾ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°ĞºÑƒ
                color_by_pca = st.selectbox(
                    "Ğ¦Ğ²ĞµÑ‚Ğ¾Ğ²Ğ¾Ğµ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:",
                    ['None'] + pca_features
                )

                fig_pca = px.scatter(
                    df_pca_viz,
                    x='PC1',
                    y='PC2',
                    color=color_by_pca if color_by_pca != 'None' else None,
                    title="PCA - ĞŸĞµÑ€Ğ²Ñ‹Ğµ Ğ´Ğ²Ğµ Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹",
                    hover_data=pca_features
                )

                st.plotly_chart(fig_pca, use_container_width=True)

            # 3D Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (ĞµÑĞ»Ğ¸ 3+ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹)
            if n_components >= 3:
                df_pca_viz['PC3'] = X_pca_transformed[:, 2]

                fig_pca_3d = px.scatter_3d(
                    df_pca_viz,
                    x='PC1',
                    y='PC2',
                    z='PC3',
                    color=color_by_pca if color_by_pca != 'None' else None,
                    title="PCA - Ğ¢Ñ€Ğ¸ Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹"
                )

                st.plotly_chart(fig_pca_3d, use_container_width=True)

            # Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚
            st.subheader("ğŸ“Š ĞĞ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚")

            loadings = pd.DataFrame(
                pca.components_.T,
                columns=[f'PC{i+1}' for i in range(n_components)],
                index=pca_features
            )

            st.dataframe(loadings.style.background_gradient(cmap='coolwarm', axis=0))

            # Heatmap Ğ½Ğ°Ğ³Ñ€ÑƒĞ·Ğ¾Ğº
            fig_loadings = px.imshow(
                loadings,
                text_auto=True,
                aspect="auto",
                title="ĞœĞ°Ñ‚Ñ€Ğ¸Ñ†Ğ° Ğ½Ğ°Ğ³Ñ€ÑƒĞ·Ğ¾Ğº ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚",
                color_continuous_scale='RdBu_r'
            )

            st.plotly_chart(fig_loadings, use_container_width=True)

# ==========================================================
# PAGE 3 â€” FORECASTING
# ==========================================================
elif page == "ğŸ“ˆ ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ":
    st.title("ğŸ“ˆ ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…")

    if 'date' not in daily_weather_df.columns:
        st.warning("Ğ”Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ½ÑƒĞ¶Ğ½Ñ‹ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ñ€ÑĞ´Ñ‹.")
    else:
        st.info("""
        **Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ** Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ñ‹
        Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….
        """)

        # Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        col1, col2, col3 = st.columns(3)

        with col1:
            forecast_city = st.selectbox(
                "Ğ“Ğ¾Ñ€Ğ¾Ğ´:",
                daily_weather_df['city_name'].unique()
            )

        with col2:
            forecast_variable = st.selectbox(
                "ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°:",
                [col for col in numeric_cols.tolist() if col not in ['year', 'month', 'season']]
            )

        with col3:
            forecast_horizon = st.slider(
                "Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ° (Ğ´Ğ½ĞµĞ¹):",
                1, 90, 30
            )

        # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
        df_forecast = daily_weather_df[
            daily_weather_df['city_name'] == forecast_city
        ].copy()

        if len(df_forecast) > 0:
            # ĞĞ³Ñ€ĞµĞ³Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ
            df_ts_forecast = df_forecast.groupby('date')[forecast_variable].mean().reset_index()
            df_ts_forecast = df_ts_forecast.sort_values('date')

            # ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ (ÑĞºĞ¾Ğ»ÑŒĞ·ÑÑ‰ĞµĞµ ÑÑ€ĞµĞ´Ğ½ĞµĞµ)
            st.subheader("ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ· Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ ÑĞºĞ¾Ğ»ÑŒĞ·ÑÑ‰ĞµĞ³Ğ¾ ÑÑ€ĞµĞ´Ğ½ĞµĞ³Ğ¾")

            # ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ÑĞºĞ¾Ğ»ÑŒĞ·ÑÑ‰ĞµĞ³Ğ¾ ÑÑ€ĞµĞ´Ğ½ĞµĞ³Ğ¾
            window_size = st.slider(
                "Ğ Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¾ĞºĞ½Ğ° Ğ´Ğ»Ñ ÑĞºĞ¾Ğ»ÑŒĞ·ÑÑ‰ĞµĞ³Ğ¾ ÑÑ€ĞµĞ´Ğ½ĞµĞ³Ğ¾:",
                3, 30, 7
            )

            # Ğ Ğ°ÑÑ‡ĞµÑ‚ ÑĞºĞ¾Ğ»ÑŒĞ·ÑÑ‰ĞµĞ³Ğ¾ ÑÑ€ĞµĞ´Ğ½ĞµĞ³Ğ¾
            df_ts_forecast['moving_avg'] = df_ts_forecast[forecast_variable].rolling(
                window=window_size,
                center=True
            ).mean()

            # Ğ­ĞºÑÑ‚Ñ€Ğ°Ğ¿Ğ¾Ğ»ÑÑ†Ğ¸Ñ (Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ğ»Ğ¸Ğ½ĞµĞ¹Ğ½Ğ°Ñ)
            last_values = df_ts_forecast[forecast_variable].tail(window_size)
            if len(last_values) >= 2:
                # ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ğ»Ğ¸Ğ½ĞµĞ¹Ğ½Ğ°Ñ ÑĞºÑÑ‚Ñ€Ğ°Ğ¿Ğ¾Ğ»ÑÑ†Ğ¸Ñ
                x = np.arange(len(last_values))
                y = last_values.values
                coef = np.polyfit(x, y, 1)

                # Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ´Ğ°Ñ‚ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°
                last_date = df_ts_forecast['date'].max()
                forecast_dates = pd.date_range(
                    start=last_date + timedelta(days=1),
                    periods=forecast_horizon,
                    freq='D'
                )

                # ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
                forecast_values = np.polyval(coef, np.arange(
                    len(last_values),
                    len(last_values) + forecast_horizon
                ))

                # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ DataFrame Ñ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¾Ğ¼
                df_forecast_future = pd.DataFrame({
                    'date': forecast_dates,
                    forecast_variable: forecast_values,
                    'type': 'ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·'
                })

                df_ts_forecast['type'] = 'Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ'

                # ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°
                df_combined = pd.concat([
                    df_ts_forecast[['date', forecast_variable, 'type']].rename(
                        columns={forecast_variable: 'value'}
                    ),
                    df_forecast_future[['date', forecast_variable, 'type']].rename(
                        columns={forecast_variable: 'value'}
                    )
                ])

                # Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
                fig_forecast = px.line(
                    df_combined,
                    x='date',
                    y='value',
                    color='type',
                    title=f"ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ· {forecast_variable} Ğ´Ğ»Ñ {forecast_city}",
                    markers=True
                )

                # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ°
                historical_std = df_ts_forecast[forecast_variable].std()

                fig_forecast.add_trace(go.Scatter(
                    x=pd.concat([forecast_dates, forecast_dates[::-1]]),
                    y=pd.concat([
                        forecast_values + historical_std,
                        (forecast_values - historical_std)[::-1]
                    ]),
                    fill='toself',
                    fillcolor='rgba(255, 0, 0, 0.2)',
                    line=dict(color='rgba(255, 255, 255, 0)'),
                    name='Ğ”Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»'
                ))

                st.plotly_chart(fig_forecast, use_container_width=True)

                # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°
                st.subheader("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°")

                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric(
                        "Ğ¡Ñ€ĞµĞ´Ğ½ĞµĞµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°",
                        f"{forecast_values.mean():.2f}"
                    )
                with col2:
                    st.metric(
                        "ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ",
                        f"{forecast_values.min():.2f}"
                    )
                with col3:
                    st.metric(
                        "ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ",
                        f"{forecast_values.max():.2f}"
                    )
                with col4:
                    st.metric(
                        "Ğ¢Ñ€ĞµĞ½Ğ´",
                        "ğŸ“ˆ Ğ’Ğ¾ÑÑ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğ¹" if coef[0] > 0 else "ğŸ“‰ ĞĞ¸ÑÑ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğ¹" if coef[0] < 0 else "â¡ï¸ Ğ¡Ñ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹"
                    )

                # Ğ¡ĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ°
                st.download_button(
                    label="ğŸ“¥ Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·",
                    data=df_forecast_future.to_csv(index=False).encode('utf-8'),
                    file_name=f"forecast_{forecast_city}_{forecast_variable}.csv",
                    mime="text/csv"
                )

# ==========================================================
# PAGE 4 â€” ABOUT
# ==========================================================
else:
    st.title("â„¹ï¸ Ğ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğµ")

    st.markdown("""
    ## Weather Analytics Dashboard

    ### ğŸ“Š ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ
    Ğ˜Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ´Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….

    ### ğŸ”§ Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»
    1. **Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…** - Ğ˜ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğ¹, ĞºĞ¾Ñ€Ñ€ĞµĞ»ÑÑ†Ğ¸Ğ¹ Ğ¸ Ğ³ĞµĞ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    2. **ĞĞ½Ğ°Ğ»Ğ¸Ğ·** - ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ, Ñ€ĞµĞ³Ñ€ĞµÑÑĞ¸Ñ, Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ÑĞ´Ğ¾Ğ², PCA
    3. **ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ** - ĞŸÑ€Ğ¾ÑÑ‚Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ³Ğ½Ğ¾Ğ·Ñ‹ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²

    ### ğŸ“ Ğ”Ğ°Ñ‚Ğ°ÑĞµÑ‚Ñ‹
    - **Daily Weather**: Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°Ğ¼
    - **Cities**: Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°Ñ…
    - **Countries**: Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ÑÑ‚Ñ€Ğ°Ğ½Ğ°Ñ…

    ### ğŸ› ï¸ Ğ¢ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸
    - **Streamlit** - Ğ¤Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€Ğº Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ´Ğ°ÑˆĞ±Ğ¾Ñ€Ğ´Ğ¾Ğ²
    - **Plotly** - Ğ˜Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°Ñ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    - **Scikit-learn** - ĞœĞ°ÑˆĞ¸Ğ½Ğ½Ğ¾Ğµ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ
    - **Pandas** - ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    - **Statsmodels** - ĞĞ½Ğ°Ğ»Ğ¸Ğ· Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ÑĞ´Ğ¾Ğ²

    ### ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
    ```bash
    pip install -r requirements.txt
    streamlit run app.py
    ```

    ### ğŸ“„ Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
    ```
    weather-dashboard/
    â”œâ”€â”€ app.py              # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    â”œâ”€â”€ requirements.txt    # Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
    â”œâ”€â”€ countries.csv      # Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ ÑÑ‚Ñ€Ğ°Ğ½Ğ°Ğ¼
    â”œâ”€â”€ cities.csv         # Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°Ğ¼
    â””â”€â”€ daily_weather_smallest.csv  # Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ³Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    ```

    ### ğŸ‘¨â€ğŸ’» Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº
    ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸Ğº Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… / Data Scientist

    ### ğŸ“§ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹
    Ğ”Ğ»Ñ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: Ğ²Ğ°Ñˆ-email@example.com
    """)

# ==========================================================
# FOOTER
# ==========================================================
st.markdown("---")
col1, col2, col3 = st.columns(3)
with col1:
    st.caption("ğŸŒ¤ï¸ Weather Analytics Dashboard")
with col2:
    st.caption(f"Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
with col3:
    st.caption("Â© 2024 Ğ’ÑĞµ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ·Ğ°Ñ‰Ğ¸Ñ‰ĞµĞ½Ñ‹")
